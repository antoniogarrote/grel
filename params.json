{"name":"Grel","tagline":"Query and manipulation library of ruby objects in a  Stardog RDF graph","body":"#GRel\r\n\r\nA small ruby library that makes it easy to store and query ruby objects stored in the RDF database [Stardog](http://stardog.com/).\r\n\r\n## Initialization\r\n```ruby\r\n    require 'grel'\r\n \r\n    include GRel\r\n\r\n    g = graph.with_db(DB)\r\n```\r\n## Linking Data\r\n\r\nGRel works with graphs of linked Ruby hashes.\r\nEvey hash in the graph will be identified by a special *@id* property. The value for the *@id* can be assigned when describing the object or it will be auto-generated by GRel if none is assigned.\r\nTo link two hashes by a property, the linked object with its corresponding *@id* value can be nested in the parent object or the value for the *@id* using the string literal \"@id(value)\" can be assigned directly.\r\n\r\nThis two queries are equivalent:\r\n```ruby\r\n    g.store(:@id     => 'abs',\r\n            :name    => 'Abhinay',\r\n            :citizen => {:@id  => 'in',\r\n                         :name => 'India'})\r\n    # abs -> citizen -> in\r\n```\r\n\r\n```ruby\r\n    g.store(:@id     => 'abs',\r\n            :name    => 'Abhinay',\r\n            :citizen => '@id(in)')\r\n    # abs -> citizen -> in\r\n```\r\nIf a string literal is used but no '@id(value)' syntax is used not object will be linked but the literal value of the string will be assigned:\r\n\r\n```ruby\r\n    g.store(:@id     => 'abs',\r\n            :name    => 'Abhinay',\r\n            :citizen => 'in')\r\n    # abs has a citizen property with the literal value 'in'\r\n```\r\n\r\nIn the description of an object, the value for the *@id' property can be specified using the *@id(value)* syntax or directly with the value.\r\n\r\nThis two queries are equivalent:\r\n```ruby\r\n    g.store(:@id     => 'abs',\r\n            :name    => 'Abhinay')\r\n```\r\n\r\n```ruby\r\n    g.store(:@id     => '@id(abs)',\r\n            :name    => 'Abhinay')\r\n```\r\n\r\n\r\n## Data loading:\r\n\r\nData is loaded as arrays of nested hashes.\r\nTwo special properties *:@id* and *:@type* are used to identify the identity of the node and its types.\r\nIdentity must be unique, type can be multiple.\r\nIf no *:@id* property is provided for an object, an identity will be generated.\r\n\r\n```ruby\r\n    g.store(:name    => 'Abhinay',\r\n            :surname => 'Mehta',\r\n            :@type   => :Developer,\r\n            :@id     => 'abs').\r\n\r\n      store(:name    => 'Tom',\r\n            :surname => 'Hall',\r\n            :@type   => :Developer,\r\n            :@id     => 'thattommyhall').\r\n\r\n      store(:name       => 'India',\r\n            :@type      => :Country,\r\n            :population => 1200,\r\n            :capital    => 'New Delhi',\r\n            :@id        => 'in').\r\n\r\n      store(:name       => 'United Kingdom',\r\n            :@type      => :Country,\r\n            :population => 62,\r\n            :capital    => 'London',\r\n            :@id        => 'uk').\r\n\r\n      # Storing relationships\r\n      store(:@id     => 'abs',\r\n            :citizen => '@id(in)').\r\n\r\n      store(:@id     => 'thattommyhall',\r\n            :citizen => '@id(uk)').\r\n\r\n      # Storing nested objects\r\n      store(:@id     => 'antoniogarrote',\r\n            :name    => 'Antonio',\r\n            :@type   => :Developer,\r\n            :citizen => {:name       => 'Spain',\r\n                         :@type      => :Country,\r\n                         :population => 43,\r\n                         :capital    => 'Madrid',\r\n                         :@id        => 'es'})             \r\n```\r\n\r\n## Querying:\r\n\r\nQueries can be performed using the *where* and passing a hash with a pattern for the nodes to be retrieved, and chaining it with the *all* methods.\r\n```ruby\r\n    g.where(:@type => :Developer).all \r\n    # [ {:@id => '@id(abs)', :name => 'Abhinay', :citizen => '@(in)'},\r\n    #   {:@id => '@id(thattommyhall)', :name => 'Tom', :citizen => '@(uk)'},\r\n    #   {:@id => '@id(antoniogarrote)', :name => 'Antonio', :citizen => '@(es)'} ]\r\n```\r\n\r\nNested objects can be retrieved specifying an empty hash for the property.\r\nBy default, the method *all* will return an array with all the objects in the recovered, including objects nested in other objects properties. \r\nIf our query returns a graph with no cycles and we want to return only the top level objects that or not linked from other objects properties, we can pass the option *:unlinked => true* to the message.\r\n```ruby\r\n    g.where(:@type => :Developer, :citizen => {}).all(:unlinked => true)\r\n    # [ {:@id => '@id(abs)', :name => 'Abhinay', ...\r\n    #    :citizen => {:@id => '@(in)', :name => 'India', ... }},\r\n    #   {:@id => '@id(thattommyhall)', :name => 'Tom', ...\r\n    #    :citizen => {:@id => '@(uk)', :name => 'United Kingdom' ... }},\r\n    #   {:@id => '@id(antoniogarrote)', :name => 'Antonio', ... \r\n    #    :citizen => {:@id => '@(es)', :name => 'Spain', ... }} ]\r\n```\r\nRelationships between objects can be specified in inverse order using a key starting with *$inv*.\r\n```ruby\r\n    g.where(:@type => :Country, \r\n            :$inv_citizen => {:name => \"Abhinay\"}).all(:unlinked => true)\r\n    # [ {:@id => '@id(in)', :name => 'India', ...'} ]\r\n```\r\nFilters can be applied to properties to select valid objects:\r\n```ruby\r\n    g.where(:@type => :Country, \r\n            :population => {:$gt => 100}).all\r\n    # [ {:@id => '@id(in)', :name => 'India', :population => 1200, ...'} ]\r\n    g.where(:@type => :Country, \r\n            :population => {:$or => [{:$lt => 50},{:$gt => 1000}]}).all\r\n    # [ {:@id => '@id(in)', :name => 'India', :population => 1200, ...'},\r\n    #   {:@id => '@id(es)', :name => 'Spain', :population => 43, ...} ]\r\n    g.where(:@type => :Country, :name => {:$like => /.+a.+/}).all\r\n    # [ {:@id => '@id(es)', :name => 'Spain', :population => 43, ...} ]\r\n```\r\nValid filters are: *$and*, *$or*, *$lt*, *$lteq*, *$gt*, *$gteq*, *$eq*, *$in* and *$like*.\r\n\r\n\r\nDifferent optional patterns can be joined in a single query using the method *union*.\r\n```ruby\r\n    g.where(:@type => :Country).union(:@type => :Developer).all\r\n    # returns all objects\r\n```\r\n\r\nIf more than one object matches a property, the final set of matching objects will be returned in an array.\r\n```ruby\r\n    g.store(:@id     => 'abs',\r\n            :citizen => '@id(uk)').\r\n\r\n      where(:name => 'Abhinay', :citizen => {}).all(:unlinked => true)\r\n    # [ {:@id => '@id(abs)', :name => 'Abhinay', ...\r\n    #    :citizen => [{:@id => '@(in)', :name => 'India', ... },\r\n    #                 {:@id => '@(uk)', :name => 'United Kingdom', ..}]} ],\r\n   \r\n```\r\n\r\n## Removing data\r\n\r\nThe message *remove* can be sent after running a query to remove the retrieved data from the graph:\r\n\r\n```ruby\r\n    g.store(:@id  => 'abs',\r\n            :name => 'Abhinay')\r\n\r\n    g.where(:@id => 'abs').remove\r\n```\r\n\r\nIf particular properties from the graph need to be removed from the graph without running a query, the *remove* message can be send directly to the graph object.\r\nThis method is the opposite to an *store* operation.\r\n\r\n```ruby\r\n    g.store(:@id        => 'es',\r\n            :name       => 'Spain',\r\n            :population => 43)\r\n\r\n    g.where(:@id => 'es').first\r\n    # {:@id => '@id(es), :name => 'Spain', :population => 43}\r\n\r\n    g.remove(:@id => 'es', :population => 43)\r\n    g.where(:@id => 'es').first\r\n    # {:@id => '@id(es), :name => 'Spain'}\r\n```\r\n\r\n## Tuple Queries\r\n\r\nSometimes we just want to retrieve particular facts from the data graph instead of full nodes. Tuple queries makes it possible to retrieve elements of a graph pattern matching the data graph. \r\nResults will be returned as hashes where each property is one of the variables in the graph pattern.\r\n\r\nTuple variables are defined in the query as symbols starting by an underscore *:_variable_name*:\r\n\r\n```ruby\r\n    g.where(:@id => :_id, \r\n            :name => :_first_name, \r\n            :citizen => { :name => 'Spain', \r\n                          :capital => :_capital }).tuples\r\n    # [ {:id => '@id(antoniogarrote)', \r\n    #    :first_name => 'Antonio', \r\n    #    :capital => 'Madrid} ]\r\n\r\n    # variables can also be added into properties not only values\r\n    g.where(:_property => \"Antonio\").tuples\r\n    # [ {:property => :name} ]\r\n```\r\n\r\n## Inference\r\n\r\nSchema information can be added using the *define* method and assertions like *@subclass*, *@subproperty*, *@domain*, *@range*.\r\n\r\n```ruby\r\n    # All developers are People\r\n    g.define(:Developer, :@subclass, :Person)   \r\n```\r\n\r\nIf inference is enabled for a connection using the *with_reasoning* method, queries will return additional results.\r\n```ruby\r\n    # No reasoning\r\n    g.where(:@type => :Person).all\r\n    # []\r\n\r\n    # With reasoning\r\n    g.with_reasoning.where(:@type => :Person).all\r\n    # [{:@id => 'id(abs)', \r\n    #   :@type => :Developer, ...},\r\n    #  {:@id => 'id(thattommyhall)', \r\n    #   :@type => :Developer, ...},\r\n    #  {:@id => 'id(antoniogarrote)', \r\n    #   :@type => :Developer, ...}]\r\n```\r\n\r\nAn example using the *@subproperty* declaration.\r\n```ruby\r\n    g.define(:citizen, :@subproperty, :bornin)   \r\n\r\n    g.with_reasoning.where(:bornin => {:@type => :Country, \r\n                                       :capital => 'Madrid'}).all\r\n    # [{:@id => 'id(antoniogarrote)', \r\n    #   :citizen => {:@id => 'id(es)', \r\n    #                :capital => 'Madrid', ... }, ...}]\r\n```\r\n\r\n\r\nAn example using the *@domain* and *@range* declarations.\r\n```ruby\r\n    g.define(:citizen, :@domain, :Citizen)   \r\n    g.define(:citizen, :@range, :State)   \r\n\r\n    g.with_reasoning.where(:@type => :Citizen, \r\n                           :citizen => {:@type => :State}).all\r\n    # [{:@id => 'id(antoniogarrote)', \r\n    #   :citizen => {:@id => 'id(es)', \r\n    #                :capital => 'Madrid', ... }, ...},\r\n    #  {:@id => 'id(thattommyhall)',  \r\n    #   :citizen => {:@id => 'id(uk)', \r\n    #                :capital => 'Madrid', ... }, ...}\r\n    #  ... ]\r\n```\r\n\r\nSchema definitions can be removed using the method *retract_definition*.\r\n\r\nAn example using the *@domain* and *@range* declarations.\r\n```ruby\r\n    g.define(:citizen, :@domain, :Citizen)   \r\n    g.define(:citizen, :@range, :State)   \r\n\r\n    g.with_reasoning.where(:@type => :Citizen, \r\n                           :citizen => {:@type => :State}).all\r\n    # [{:@id => 'id(antoniogarrote)', \r\n    #   :citizen => {:@id => 'id(es)', \r\n    #                :capital => 'Madrid', ... }, ...},\r\n    #  {:@id => 'id(thattommyhall)',  \r\n    #   :citizen => {:@id => 'id(uk)', \r\n    #                :capital => 'Madrid', ... }, ...}\r\n    #  ... ]\r\n\r\n    g.retract_definition(:citizen, :@range, :State).where(:@type => :Citizen, :citizen => {:@type => :State}).all\r\n    # [ ]\r\n```\r\n\r\nInference can be disabled sending the *without_reasoning* message.\r\n\r\n## Validations\r\n\r\nReasoning support can also be used to validate the objects you insert in the graph. In this case, your schema definitions are interpreted not to infere new knowledge but to check that the structure of the objects inserted match the schema.\r\n\r\nValidations can be introduced in the graph using the *validate* message that receives an assertion with the *@subclass*, *@subproperty*, *@domain* or *@range* properties.\r\n\r\nValidations are turned on/off using the *with_validations* and *without_validations* messages.\r\n\r\nIf a validation is violated, an exception will be raised. If validations are turned on and there's already invalid data in the graph, no further insertions will succeed.\r\n\r\nValidations can also be removed using the *retract_validation* message.\r\n\r\n```ruby\r\n    g = graph.with_db(DB) # new graph\r\n\r\n    g.with_validations.validate(:citizen, :@domain, :State)   \r\n\r\n    g.store(:@id => 'id(malditogeek)', \r\n            :citizen => {:@id => 'id(ar)', \r\n                         :capital => 'Buenos Aires'}, ...)\r\n\r\n    # An exception is raised due to validation violation\r\n\r\n    g.store(:@id => 'ar', \r\n            :capital => 'Buenos Aires', \r\n            :@type => :State, \r\n            :name => 'Argentina').\r\n      store(:@id => 'id(malditogeek)', \r\n            :citizen => '@id(ar)')\r\n    # After adding the @type for Argentina, the insertion does not raise any exception.\r\n```\r\n\r\nValidations and inference can be used together to infere additional infromation that will make data valid according to the defined validations:\r\n\r\n```ruby\r\n    g = graph.with_db(DB) # new graph\r\n\r\n    g.with_validations.validate(:citizen, :@domain, :State)   \r\n\r\n    g.store(:@id => 'id(malditogeek)', \r\n            :citizen => {:@id => 'id(ar)', \r\n                         :capital => 'Buenos Aires'}, ...)\r\n\r\n    # An exception is raised due to validation violation\r\n\r\n    g.with_reasoning.define(:citizen, :@domain, :State).\r\n      store(:@id => 'id(malditogeek)', \r\n            :citizen => {:@id => 'id(ar)', \r\n                         :capital => 'Buenos Aires'}, ...)\r\n    # Data is valid using reasoning since the @type :State for Argentina can be inferred.\r\n\r\n    g.where(:@type => :Citizen, \r\n            :citizen => {:@type => :State}).all\r\n    # [{:@id => 'id(malditogeek)', \r\n    #   :citizen => {:@id => 'id(ar)', \r\n    #                :capital => 'Buenos Aires', ... }, ...}]\r\n\r\n    g.without_reasoning # graph is invalid now, no further operations can be committed.\r\n\r\n    g.without_validations # graph is again valid since no validations will be checked.\r\n```\r\nSome examples of validations are:\r\n\r\n - Data types in range, using the corresponding class *Date*, *Float*, *Fixnum*, *TrueClass* / *FalseClass*:\r\n\r\n```ruby\r\n    g = graph.with_db(DB) # new graph\r\n\r\n    g.with_validations.validate(:born, :@domain, Date) # born must have a Date value\r\n\r\n    g.store(:@id => 'antoniogarrote', :born => \"1982-05-01\", ...)\r\n\r\n    # An exception is raised due to validation violation, :born has a string value not a date vaue\r\n\r\n    g.store(:@id => 'antoniogarrote', :born => Date.parse(\"1982-05-01\"), ...)\r\n\r\n    # No validation error is raised\r\n```\r\n\r\n - Subclass / Superclass relationships\r\n\r\n```ruby\r\n    g = graph.with_db(DB) # new graph\r\n\r\n    g.with_validations.validate(:Developer, :@subclass, :Person) # all Developers must be human!\r\n\r\n    g.store(:@id => 'abhinay', :@type => :Developer, ...)\r\n\r\n    # An exception is raised due to validation violation, :Person @type is missing\r\n\r\n    g.store(:@id => 'abhinay', :@type => [:Developer, :Person], ...)\r\n\r\n    # No validation error is raised\r\n```\r\n\r\n - Participation constraints\r\n\r\n```ruby\r\n    g = graph.with_db(DB)\r\n\r\n    g.with_validations.validate(:Supervisor, :@some, [:supervises, :Employee])\r\n\r\n    g.store(:@type  => :Supervisor)\r\n\r\n    # An exception is raised, Supervisors must supervise employees\r\n    \r\n    g.store(:@type  => :Supervisor, :supervises => {:@type => :Employee})\r\n\r\n    # No validation error is raised\r\n```\r\n\r\n```ruby\r\n    g = graph.with_db(DB)\r\n\r\n    g.with_validations.validate(:Supervisor, :@all, [:supervises, :Employee])\r\n\r\n    g.store(:@type  => :Supervisor, \r\n            :supervises => [{:@id => 'a', :@type => :Employee},\r\n                            {:@id => 'b', :@type => :Assistant}])\r\n\r\n    # An exception is raised, all objectes supervised by a Supervisor must belong to\r\n    # the Employee class\r\n    \r\n    g.store(:@type  => :Supervisor, \r\n            :supervises => [{:@id => 'a', :@type => :Employee},\r\n                            {:@id => 'b', :@type => [:Assistant, :Employee]}])\r\n\r\n\r\n    # No validation error is raised\r\n```\r\n\r\n - Cardinality constraints\r\n\r\n```ruby\r\n    g = graph.with_db(DB).with_validations\r\n\r\n    g.validate(:Person, :@cardinality, {:property => :lives, \r\n                                        :max => 1, \r\n                                        :min => 1})\r\n\r\n    g.store(:@type => :Person,\r\n            :name => 'Antonio',\r\n            :lives => [{:@id => 'es'},{:@id => 'uk'}])\r\n\r\n\r\n    # An exception is raised, People can only live in one place\r\n\r\n    g.store(:@type => :Person,\r\n            :name => 'Antonio',\r\n            :lives => '@id(uk)')\r\n\r\n    # No validation error is raised\r\n```\r\n\r\nThe details about how to use validations can be found in the Stardog documentation related to ICV (Integrity Constraints Validations) for the data base (http://stardog.com/docs/sdp/#validation).\r\n\r\n## License\r\n\r\nLicensed under the Apache2 license.\r\n\r\n## Author and contact:\r\n\r\nAntonio Garrote (antoniogarrote@gmail.com)\r\n","google":"UA-39541845-1","note":"Don't delete this file! It's used internally to help with page regeneration."}